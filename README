# Install

After the requirements are installed, TADASHI can be `pip` installed from GitHub using:

```bash
pip install tadashi
```

Requirements are LLVM, clang, autotools, pkgconfig, libyaml, libntl, libgmp, swig. The exact `apt-get` packages can be found in [this file](./.github/workflows/tests.yaml).

Using [Docker](./deps/docker/) is also an option.


## Development

```bash
cmake -S . -B build -GNinja -DCMAKE_INSTALL_PREFIX=ctadashi -DCALL_FROM_SETUP_PY=ON
ninja -C build install
```

Execute with:

```bash
PYTHONPATH=. python examples/end2end.py
```


# Documentation

After the double blind review and the end of the anonymity requirement, detailed API documentation will be uploaded to <https://tadashi.readthedocs.io/> (or a similar URL).


## Quick start

An [end-to-end](./examples/inputs/end2end.py) example is provided below (split into parts with comments and outputs). This example can be run from the repository root with the following command:

```bash
python examples/inputs/end2end.py
```


### End-to-end example

After importing Tadashi we obtain the loop nests (SCoPs) from a [Simple](./tadashi/apps.py) app.

```python
#!/bin/env python
from pathlib import Path
from random import choice, seed

import tadashi
from tadashi.apps import Simple

seed(1234)

dir_path = Path(__file__).parent
examples_path = dir_path if dir_path.name == "examples" else "examples"
app = Simple(f"{examples_path}/inputs/depnodep.c")
print(app)
```

    =========================
    TRANSFORMATIONS=[<class 'tadashi.InterchangeInfo'>]

Select a node and a transformation, and check that the transformation is available on the selected node.

```python
node = app.scops[0].schedule_tree[1]
print(f"{node=}")
tr = choice(node.available_transformations)
print(f"{tr=}")
# output:
```

Check the available arguments for the given node-transformation pair.

```python
args = choice(node.get_args(tr, -10, 10))
print(f"{args=}")
# output:
```

Perform the transformation and check legality.

```python
legal = node.transform(tr, *args)
print(f"{legal=}")
# output:
```

Generate new code, compile it and measure the performance.

```python
app.compile()
print(f"{app.measure()=}")
transformed_app = app.generate_code()
transformed_app.compile()
print(f"{transformed_app.measure()=}")
# output:
```
